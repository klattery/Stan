if (sum(dim(sim_pop) != dim(est_utilities)) > 0){
stop("Fatal Error: simulated and estimated utilities must be same size (rows and cols)")
}
plot(as.vector(sim_pop), as.vector(est_utilities), main = "Compare Utilities", xlab = "Simulated Population Utilities", ylab = "Estimated Utilities")
plot(as.vector(cor(sim_pop)), as.vector(cor(est_utilities)), main = "Compare Correlation of Utilities", xlab = "Simulated Population Cor", ylab = "Estimated Correlation")
plot(as.vector(cov(sim_pop)), as.vector(cov(est_utilities)), main = "Compare Covariance of Utilities", xlab = "Simulated Population Cov", ylab = "Estimated Covaraince")
utility_stats <- list(
MAE_utils = mean(abs(est_utilities - sim_pop)),
cor_utils = cor(as.vector(est_utilities), as.vector(sim_pop)),
mean_vars = data.frame(sim_pop = colMeans(sim_pop), est_utils = colMeans(est_utilities)),
sd_vars = data.frame(sim_pop = apply(sim_pop, 2, sd), est_utils = apply(est_utilities, 2, sd)),
sd_rows = data.frame(sim_pop = apply(sim_pop, 1, sd), est_utils = apply(est_utilities, 1, sd)),
row_cor = data.frame(row_cor = sapply(1:nrow(sim_pop), function(i) cor(sim_pop[i,], est_utiities[i,])))
)
plot(utility_stats$mean_vars, main = "Compare Means of Utility Variables")
plot(utility_stats$sd_vars, main = "Compare Std Deviations of Utility Variables")
plot(utility_stats$sd_rows, main = "Compare Std Deviations of Each Respondent's Utilities")
holdout_stats <- holdout_detail <- holdout_agg <- NULL
if (nholdouts > 0){
fixed_tasks <- sample((1:data_stan$T), nholdouts) # Fixed tasks
result <- do.call(rbind, lapply(1:nrow(sim_pop), function(i){
MNL_holdout_compare_one(data_stan, sim_pop[i,], est_utilities[i,],
id = i,
hold_tasks = intersect(fixed_tasks, (1:data_stan$T)[data_stan$task_individual != i]))
}))
sim_pred_agg <- sqldf("select task, concept, avg(sim_pred) as sim_pred, avg(est_pred) as est_pred from result group by
task, concept")
plot(sim_pred_agg$sim_pred, sim_pred_agg$est_pred, main = "Compare Aggregate Shares of Holdout Tasks",
xlab = "Agg Shares from Simulated Utilities",
ylab = "Agg Shares from Estimated Utilities")
holdout_stats <- list(
MAE_agg = mean(abs(sim_pred_agg$sim_pred - sim_pred_agg$est_pred)),
hit_rate = sum(result$sim_choice * result$est_choice)/sum(result$sim_choice),
rlh = exp(sum(result$sim_choice * log(result$est_pred))/sum(result$sim_choice)),
MAE_resp_probs = mean(abs(result$est_pred - result$sim_pred)),
cor_resp_probs = cor(result$sim_pred,result$est_pred),
)
}
return(list(holdout_stats = holdout_stats, utility_stats = utility_stats, holdout_agg = sim_pred_agg, holdout_detail = result))
}
holdout_fit <- compare_utilities(data_stan, sim_pop, utilities, 30)
compare_utilities <- function(data_stan, sim_pop, est_utilities, nholdouts){
if (sum(dim(sim_pop) != dim(est_utilities)) > 0){
stop("Fatal Error: simulated and estimated utilities must be same size (rows and cols)")
}
plot(as.vector(sim_pop), as.vector(est_utilities), main = "Compare Utilities", xlab = "Simulated Population Utilities", ylab = "Estimated Utilities")
plot(as.vector(cor(sim_pop)), as.vector(cor(est_utilities)), main = "Compare Correlation of Utilities", xlab = "Simulated Population Cor", ylab = "Estimated Correlation")
plot(as.vector(cov(sim_pop)), as.vector(cov(est_utilities)), main = "Compare Covariance of Utilities", xlab = "Simulated Population Cov", ylab = "Estimated Covaraince")
utility_stats <- list(
MAE_utils = mean(abs(est_utilities - sim_pop)),
cor_utils = cor(as.vector(est_utilities), as.vector(sim_pop)),
mean_vars = data.frame(sim_pop = colMeans(sim_pop), est_utils = colMeans(est_utilities)),
sd_vars = data.frame(sim_pop = apply(sim_pop, 2, sd), est_utils = apply(est_utilities, 2, sd)),
sd_rows = data.frame(sim_pop = apply(sim_pop, 1, sd), est_utils = apply(est_utilities, 1, sd)),
row_cor = data.frame(row_cor = sapply(1:nrow(sim_pop), function(i) cor(sim_pop[i,], est_utiities[i,])))
)
plot(utility_stats$mean_vars, main = "Compare Means of Utility Variables")
plot(utility_stats$sd_vars, main = "Compare Std Deviations of Utility Variables")
plot(utility_stats$sd_rows, main = "Compare Std Deviations of Each Respondent's Utilities")
holdout_stats <- holdout_detail <- holdout_agg <- NULL
if (nholdouts > 0){
fixed_tasks <- sample((1:data_stan$T), nholdouts) # Fixed tasks
result <- do.call(rbind, lapply(1:nrow(sim_pop), function(i){
MNL_holdout_compare_one(data_stan, sim_pop[i,], est_utilities[i,],
id = i,
hold_tasks = intersect(fixed_tasks, (1:data_stan$T)[data_stan$task_individual != i]))
}))
sim_pred_agg <- sqldf("select task, concept, avg(sim_pred) as sim_pred, avg(est_pred) as est_pred from result group by
task, concept")
plot(sim_pred_agg$sim_pred, sim_pred_agg$est_pred, main = "Compare Aggregate Shares of Holdout Tasks",
xlab = "Agg Shares from Simulated Utilities",
ylab = "Agg Shares from Estimated Utilities")
holdout_stats <- list(
MAE_agg = mean(abs(sim_pred_agg$sim_pred - sim_pred_agg$est_pred)),
hit_rate = sum(result$sim_choice * result$est_choice)/sum(result$sim_choice),
rlh = exp(sum(result$sim_choice * log(result$est_pred))/sum(result$sim_choice)),
MAE_resp_probs = mean(abs(result$est_pred - result$sim_pred)),
cor_resp_probs = cor(result$sim_pred,result$est_pred)
)
}
return(list(holdout_stats = holdout_stats, utility_stats = utility_stats, holdout_agg = sim_pred_agg, holdout_detail = result))
}
holdout_fit <- compare_utilities(data_stan, sim_pop, utilities, 30)
look <- holdout_fit$holdout_detail
View(look)
compare_utilities <- function(data_stan, sim_pop, est_utilities, nholdouts){
if (sum(dim(sim_pop) != dim(est_utilities)) > 0){
stop("Fatal Error: simulated and estimated utilities must be same size (rows and cols)")
}
plot(as.vector(sim_pop), as.vector(est_utilities), main = "Compare Utilities", xlab = "Simulated Population Utilities", ylab = "Estimated Utilities")
plot(as.vector(cor(sim_pop)), as.vector(cor(est_utilities)), main = "Compare Correlation of Utilities", xlab = "Simulated Population Cor", ylab = "Estimated Correlation")
plot(as.vector(cov(sim_pop)), as.vector(cov(est_utilities)), main = "Compare Covariance of Utilities", xlab = "Simulated Population Cov", ylab = "Estimated Covaraince")
utility_stats <- list(
MAE_utils = mean(abs(est_utilities - sim_pop)),
cor_utils = cor(as.vector(est_utilities), as.vector(sim_pop)),
mean_vars = data.frame(sim_pop = colMeans(sim_pop), est_utils = colMeans(est_utilities)),
sd_vars = data.frame(sim_pop = apply(sim_pop, 2, sd), est_utils = apply(est_utilities, 2, sd)),
sd_rows = data.frame(sim_pop = apply(sim_pop, 1, sd), est_utils = apply(est_utilities, 1, sd)),
row_cor = data.frame(row_cor = sapply(1:nrow(sim_pop), function(i) cor(sim_pop[i,], est_utiities[i,])))
)
plot(utility_stats$mean_vars, main = "Compare Means of Utility Variables")
plot(utility_stats$sd_vars, main = "Compare Std Deviations of Utility Variables")
plot(utility_stats$sd_rows, main = "Compare Std Deviations of Each Respondent's Utilities")
holdout_stats <- holdout_detail <- holdout_agg <- NULL
if (nholdouts > 0){
fixed_tasks <- sample((1:data_stan$T), nholdouts) # Fixed tasks
result <- do.call(rbind, lapply(1:nrow(sim_pop), function(i){
MNL_holdout_compare_one(data_stan, sim_pop[i,], est_utilities[i,],
id = i,
hold_tasks = intersect(fixed_tasks, (1:data_stan$T)[data_stan$task_individual != i]))
}))
sim_pred_agg <- sqldf("select task, concept, avg(sim_pred) as sim_pred, avg(est_pred) as est_pred, sum(1) as N from result group by
task, concept")
plot(sim_pred_agg$sim_pred, sim_pred_agg$est_pred, main = "Compare Aggregate Shares of Holdout Tasks",
xlab = "Agg Shares from Simulated Utilities",
ylab = "Agg Shares from Estimated Utilities")
holdout_stats <- list(
MAE_agg = mean(abs(sim_pred_agg$sim_pred - sim_pred_agg$est_pred)),
hit_rate = sum(result$sim_choice * result$est_choice)/sum(result$sim_choice),
rlh = exp(sum(result$sim_choice * log(result$est_pred))/sum(result$sim_choice)),
MAE_resp_probs = mean(abs(result$est_pred - result$sim_pred)),
cor_resp_probs = cor(result$sim_pred,result$est_pred)
)
}
return(list(holdout_stats = holdout_stats, utility_stats = utility_stats, detail_agg = sim_pred_agg, detail_resp = result))
}
holdout_fit <- compare_utilities(data_stan, sim_pop, utilities, 30)
look <- holdout_fit$detail_agg
View(look)
compare_utilities <- function(data_stan, sim_pop, est_utilities, tasks_holdout = NULL){
if (sum(dim(sim_pop) != dim(est_utilities)) > 0){
stop("Fatal Error: simulated and estimated utilities must be same size (rows and cols)")
}
plot(as.vector(sim_pop), as.vector(est_utilities), main = "Compare Utilities", xlab = "Simulated Population Utilities", ylab = "Estimated Utilities")
plot(as.vector(cor(sim_pop)), as.vector(cor(est_utilities)), main = "Compare Correlation of Utilities", xlab = "Simulated Population Cor", ylab = "Estimated Correlation")
plot(as.vector(cov(sim_pop)), as.vector(cov(est_utilities)), main = "Compare Covariance of Utilities", xlab = "Simulated Population Cov", ylab = "Estimated Covaraince")
utility_stats <- list(
MAE_utils = mean(abs(est_utilities - sim_pop)),
cor_utils = cor(as.vector(est_utilities), as.vector(sim_pop)),
mean_vars = data.frame(sim_pop = colMeans(sim_pop), est_utils = colMeans(est_utilities)),
sd_vars = data.frame(sim_pop = apply(sim_pop, 2, sd), est_utils = apply(est_utilities, 2, sd)),
sd_rows = data.frame(sim_pop = apply(sim_pop, 1, sd), est_utils = apply(est_utilities, 1, sd)),
row_cor = data.frame(row_cor = sapply(1:nrow(sim_pop), function(i) cor(sim_pop[i,], est_utiities[i,])))
)
plot(utility_stats$mean_vars, main = "Compare Means of Utility Variables")
plot(utility_stats$sd_vars, main = "Compare Std Deviations of Utility Variables")
plot(utility_stats$sd_rows, main = "Compare Std Deviations of Each Respondent's Utilities")
holdout_stats <- holdout_detail <- holdout_agg <- NULL
if (!is.null(tasks_holdout)){
fixed_tasks <- sample((1:data_stan$T), nholdouts) # Fixed tasks
result <- do.call(rbind, lapply(1:nrow(sim_pop), function(i){
MNL_holdout_compare_one(data_stan, sim_pop[i,], est_utilities[i,],
id = i,
hold_tasks = intersect(tasks_holdout, (1:data_stan$T)[data_stan$task_individual != i]))
}))
sim_pred_agg <- sqldf("select task, concept, avg(sim_pred) as sim_pred, avg(est_pred) as est_pred, sum(1) as N from result group by
task, concept")
plot(sim_pred_agg$sim_pred, sim_pred_agg$est_pred, main = "Compare Aggregate Shares of Holdout Tasks",
xlab = "Agg Shares from Simulated Utilities",
ylab = "Agg Shares from Estimated Utilities")
holdout_stats <- list(
MAE_agg = mean(abs(sim_pred_agg$sim_pred - sim_pred_agg$est_pred)),
hit_rate = sum(result$sim_choice * result$est_choice)/sum(result$sim_choice),
rlh = exp(sum(result$sim_choice * log(result$est_pred))/sum(result$sim_choice)),
MAE_resp_probs = mean(abs(result$est_pred - result$sim_pred)),
cor_resp_probs = cor(result$sim_pred,result$est_pred)
)
}
return(list(holdout_stats = holdout_stats, utility_stats = utility_stats, detail_agg = sim_pred_agg, detail_resp = result))
}
holdout_fit <- compare_utilities(data_stan, sim_pop, utilities,
tasks_holdout = sample(1:data_stan$T, 30)) # Fixed tasks)
library(parallel)
test <- mclapply(1:200, function(x) rnorm(1000))
ntest <- 80
ntest_perver <- 20
ntest_comp <- 0
show_eachitem <- 2
items_task <- 2
n_versions <- 100
restrictions_table <- NULL
constraints_table <- NULL
shiny <- FALSE
if(shiny) {
progress <- shiny::Progress$new()
on.exit(progress$close())
progress$set(message = 'Calculating', value = 0)
}
# SPECIFY PARAMETERS HERE#
set_test <- 1:ntest # vector of item numbers to be used as test items
ntest_perver <- ntest_perver # How many test items are used for each specific version
if (ntest_comp == 0) {
set_comp <- NULL
} else {
set_comp <- ((ntest+1):(ntest+ntest_comp))
}
if (is.null(restrictions_table)) {
must_haves <- as.data.frame(c(1:n_versions))
} else {
must_haves <- as.data.frame(restrictions_table)
}
if (is.null(constraints_table)) {
con_pairs <- NULL
} else {
df <- as.data.frame(constraints_table)
newlist <- lapply(split(df, row.names(df)), unlist)
con_pairs <- lapply(newlist, function(x) x[!is.na(x)])
}
#######################################################################
####   Just Run this Code to Create Defaults and Helper Variables  ####
#######################################################################
# Check that these are what you expect
n_ver <- nrow(must_haves) # number of versions to create
n_items <- ntest_perver + length(set_comp) # number of items shown in a version
n_tasks <-  round(n_items * show_eachitem/items_task,0) # number of tasks in a version, assume each task is a pair of items = 2
set_test_r <- 1:length(set_test) # recode test values to 1:n
#Create default target and target_wt for test items shown n x n where n = number of test items
target_freq <- (n_ver*ntest_perver)/length(set_test_r)
target_cov_num <- choose(ntest_perver, 2) # Pairs in version
target_cov_den <- (length(set_test_r)^2 - length(set_test_r))/2 # Total Pairs of target
target_cov <- n_ver * target_cov_num/target_cov_den
target_1 <- matrix(target_cov, nrow = length(set_test_r), ncol = length(set_test_r))
diag(target_1) <- target_freq
target_1_wt <- matrix(1, nrow = nrow(target_1), ncol=ncol(target_1))
diag(target_1_wt) <- (nrow(target_1)-1) * 1
# Define Functions
ind_code <- function(vec_val, klength){
vec0 <- rep(0, klength)
vec0[vec_val] <- 1
return(vec0)
}
gen_design <- function(dummy, design_in, npicks, target, target_wt){
design <- design_in
for (iter in 1:10){
for (i in sample(nrow(design))){
rowpick <- design[i,]
musthave <- design_in[i,]
design_minus <- design[-i,]
show_minus <- t(design_minus) %*% design_minus
need_minus <- target_wt * (target - show_minus)
test <- do.call(rbind, lapply(1:2000, function(x) sample(x=ncol(design), size=npicks, prob = 1-design_in[i,])))
test_ind <- t(apply(test,1,ind_code, ncol(design)))
test_ind <- test_ind + do.call(rbind,lapply(1:nrow(test_ind), function(x) musthave))
if (iter > 1){
test_ind <- rbind(rowpick,test_ind)
}
kfit <- apply(test_ind %*% need_minus, 1, sum)
fitbest <- which(kfit == max(kfit))
pick <- sample(fitbest, 1)
rowpick <- test_ind[pick,] # add new pick
design[i,] <- rowpick
}
}
return(design)
}
compfit <- function (pdesign, target, target_wt){
show_now <- t(pdesign) %*% pdesign
return(sum(target_wt * abs(show_now - target)))
}
gen_design_pair <- function(task_code, n_tasks, target_en, target_wt){
# pick 2 random tasks
pick <- sample(1:nrow(task_code),2)
design <- task_code[pick,]
task_code <- task_code[-pick,] #drop pick
# now loop through adding picks
for (i in 1:(n_tasks - nrow(design))){
show_now <- t(design) %*% design
need <- target_wt * (target_en - show_now)
fit_ver <- apply(task_code %*% need, 1, sum)
vmax <- max(fit_ver)
vbest <- (fit_ver >= (vmax - .00001)) #rows that are best (or nearly)
pick <- sample(which(vbest),1)
design <- rbind(design, task_code[pick,])
task_code <- task_code[-pick,] #drop pick
}
return(design)
}
fix_con <- function(x, con_pairs){
# Fix constraints, if con_pairs is null does nothing
check_bad <- function(x, con_pairs){
bad <- duplicated(x)
if (!is.null(con_pairs)){
kmatch <- sapply(con_pairs, function(pair) rowSums(x[,pair]))
bad <- bad | (rowSums(kmatch == 2) > 0)
}
return(bad)
}
bad <- check_bad(x, con_pairs)
iter <- 0
while (sum(bad) > 0 & iter < 500){
if (sum(bad) == nrow(x)) bad[1] <- FALSE # Can't have all bad
x <- rbind(x[bad,], x[!bad,])
for (i in 1:sum(bad)){
badrow <- which(x[i,] == 1)
subrow <- sample((i+1):nrow(x), 1)
nextrow <-  which(x[subrow,] == 1)
if (length(intersect(badrow, nextrow)) == 0) {
x[i,badrow[2]] <- 0
x[i,nextrow[2]] <- 1
x[subrow,nextrow[2]] <- 0
x[subrow,badrow[2]] <- 1
}
}
iter <- iter + 1
bad <- check_bad(x, con_pairs)
} # end while
if (sum(bad) > 0){
stop("FATAL Error: Could not Create Version of Tasks with Constraints and without Dups")
}
return(x)
}
#########################################################
#                   STAGE 1                             #
#    Get Items to Be Tested: design_itemsall            #
#########################################################
# Check target (target 1-way and 2-way) and target_wt (how important to hit target)
# Adjust them if desired
diag(target_1_wt) <- (nrow(target_1)-1) * 2 # *2 or *5 for better one way
designs_stage1 <- 30 # 10 is reasonable, but can go higher if needed (30 takes time)
# Generate design_itemsall
design <- matrix(0, nrow = n_ver, ncol = length(set_test_r))
if ((ncol(must_haves)) > 1){
must_haves_r <- must_haves[,-1] # drop first column
must_haves_r <- apply(must_haves_r,2,match,set_test) # recode so this matches 1:n values of set_test_r
for (i in 1:nrow(design)){
kvalue <- must_haves_r[i,]
design[i,kvalue] <- 1
} # design has initial design based on must_haves, but indicator coded
}
design_in <- design # Keep copy of initial design
# Next step TAKES TIME
if(shiny) progress$inc(.2, message = "1. Creating Design for Items Shown Each Version")
if(!shiny) message("1. Creating Design for Items Shown Each Version")
gen_design
multdesigns <- lapply(1:2, gen_design, design_in, ntest_perver, target_1, target_1_wt)
diag(target_1_wt)
View(design_in)
? mclapply
r_cores <- 6
check <- mclapply(1:10, function(i) rnorm(100))
# user interface
ui <- fluidPage(
# theme = shinytheme("flatly"),
tags$style("p { color: blue;}"),
titlePanel(title=div(img(src="skim.png", height = 70), "Unspoken Design Generator"),windowTitle = "Unspoken Design"),
sidebarLayout(
sidebarPanel(
h4(p("Client and Optional Competitor Items:")),
numericInput("numberitems", label = "Number of total client items:", value = 10),
numericInput("ntest_perver", label = "Number of client items to be shown per version (subset):", value = 5),
numericInput("compitems", label = "Number of competitor items, always shown in each version, not included in client items:", value = 0),
h5(strong(htmlOutput("sample_size"))),
h4(p("Attraction:")),
numericInput("show_eachitem_att", label = "Number of times to show each item in attraction (not a decimal). Recommended is 2+:", value = 2),
h4(p("Conversion:")),
numericInput("show_eachitem", label = "Number of times to show each item in conversion (can be a decimal). Recommended is 2.5+:", value = 3),
numericInput("items_task", label = "Number of items to show in each conversion task (not a decimal). 2 is standard:", value = 2),
h4(p("Other Specs:")),
numericInput("numberversions", label = "Number of versions:", value = 100),
fileInput("restrictions", "Choose Restrictions CSV (UTF-8) if there are restrictions on items in versions. CSV should have columns: version, item1, ..., itemn. Must have a row for each version.", multiple = FALSE, accept = c(
"text/csv",
"text/comma-separated-values,text/plain",
".csv", label = "Restrictions File")),
fileInput("constraints", "Choose Constraints CSV (UTF-8) if there are items that can't be shown together. CSV should have 2 columns.  Each row has a pair of items that cannot be shown together.", multiple = FALSE, accept = c(
"text/csv",
"text/comma-separated-values,text/plain",
".csv", label = "Constraints File")),
actionButton("setup_ready","Setup Done", class = "btn-primary"),
h4("Download Files once program finishes running:"),
h3(downloadButton("downconversion","Conversion Design")),
h3(downloadButton("downattraction","Attraction Design"))
),
mainPanel(
wellPanel(style = "background:#E1EBFE",
h3("Hi, Welcome to the Unspoken-Design Generator Portal!"),
h4("Please be patient. Your design will take some time to run so we can make sure it is well balanced.
Processing time depends on number of items and versions. You will know your designs are ready when you see the 1-way tables in the checks below.
Have a great day and good luck with your Unspoken Project!"),
),
h4("Conversion Frequency Checks:"),
h5("Total times each item was shown across all versions:"),
h6(dataTableOutput("conversion_checks")),
h5("Total times each item was shown for each version:"),
h6(dataTableOutput("conversion_checks_2")),
h4("Attraction Frequency Checks:"),
h5("Total times each item was shown across all versions:"),
h6(dataTableOutput("att_1_checks")),
h5("Total times each item was shown for each version:"),
h6(dataTableOutput("att_1_checks_2")),
)))
library(shiny)
# user interface
ui <- fluidPage(
# theme = shinytheme("flatly"),
tags$style("p { color: blue;}"),
titlePanel(title=div(img(src="skim.png", height = 70), "Unspoken Design Generator"),windowTitle = "Unspoken Design"),
sidebarLayout(
sidebarPanel(
h4(p("Client and Optional Competitor Items:")),
numericInput("numberitems", label = "Number of total client items:", value = 10),
numericInput("ntest_perver", label = "Number of client items to be shown per version (subset):", value = 5),
numericInput("compitems", label = "Number of competitor items, always shown in each version, not included in client items:", value = 0),
h5(strong(htmlOutput("sample_size"))),
h4(p("Attraction:")),
numericInput("show_eachitem_att", label = "Number of times to show each item in attraction (not a decimal). Recommended is 2+:", value = 2),
h4(p("Conversion:")),
numericInput("show_eachitem", label = "Number of times to show each item in conversion (can be a decimal). Recommended is 2.5+:", value = 3),
numericInput("items_task", label = "Number of items to show in each conversion task (not a decimal). 2 is standard:", value = 2),
h4(p("Other Specs:")),
numericInput("numberversions", label = "Number of versions:", value = 100),
fileInput("restrictions", "Choose Restrictions CSV (UTF-8) if there are restrictions on items in versions. CSV should have columns: version, item1, ..., itemn. Must have a row for each version.", multiple = FALSE, accept = c(
"text/csv",
"text/comma-separated-values,text/plain",
".csv", label = "Restrictions File")),
fileInput("constraints", "Choose Constraints CSV (UTF-8) if there are items that can't be shown together. CSV should have 2 columns.  Each row has a pair of items that cannot be shown together.", multiple = FALSE, accept = c(
"text/csv",
"text/comma-separated-values,text/plain",
".csv", label = "Constraints File")),
actionButton("setup_ready","Setup Done", class = "btn-primary"),
h4("Download Files once program finishes running:"),
h3(downloadButton("downconversion","Conversion Design")),
h3(downloadButton("downattraction","Attraction Design"))
),
mainPanel(
wellPanel(style = "background:#E1EBFE",
h3("Hi, Welcome to the Unspoken-Design Generator Portal!"),
h4("Please be patient. Your design will take some time to run so we can make sure it is well balanced.
Processing time depends on number of items and versions. You will know your designs are ready when you see the 1-way tables in the checks below.
Have a great day and good luck with your Unspoken Project!"),
),
h4("Conversion Frequency Checks:"),
h5("Total times each item was shown across all versions:"),
h6(dataTableOutput("conversion_checks")),
h5("Total times each item was shown for each version:"),
h6(dataTableOutput("conversion_checks_2")),
h4("Attraction Frequency Checks:"),
h5("Total times each item was shown across all versions:"),
h6(dataTableOutput("att_1_checks")),
h5("Total times each item was shown for each version:"),
h6(dataTableOutput("att_1_checks_2")),
)))
# server
server <- function(input, output) {
# recommended sample size
output$sample_size <- renderText({
sample <- ((300*input$numberitems)/input$ntest_perver)
text<- paste("Your minimum sample size is:","<font color=\"#F27524\">",sample,"</font>", ". Based on total client items and subset size. Sample Size = 300*total_items/items_per_version.")
text
})
# read file from user
restrictions_table <- reactive({
if (is.null(input$restrictions)) {
restrictions <- NULL
} else {
restrictions <- read.csv(input$restrictions$datapath)
}
restrictions})
constraints_table <- reactive({
if (is.null(input$constraints)) {
constraints <- NULL
} else {
constraints <- read.csv(input$constraints$datapath)
}
constraints})
observeEvent(input$setup_ready, {
conversion_design <- reactive({
final <- conversion_function(input$numberitems, input$ntest_perver, input$compitems, input$show_eachitem,  input$items_task, input$numberversions, restrictions_table(), constraints_table())
final
})
attraction_design <- reactive({
final <- attraction_function(conversion_design(), input$show_eachitem_att)
final
})
output$conversion_checks <- renderDataTable({dcast(conversion_design(), . ~ item, value.var = 'item', fun.aggregate = length)})
output$conversion_checks_2 <- renderDataTable({dcast(conversion_design(), version ~ item, value.var = 'item', fun.aggregate = length)})
output$att_1_checks <- renderDataTable({dcast(attraction_design(), . ~ item, value.var = 'item', fun.aggregate = length)})
output$att_1_checks_2 <- renderDataTable({dcast(attraction_design(), version ~ item, value.var = 'item', fun.aggregate = length)})
output$downconversion <- downloadHandler(
filename = "ConversionDesign.csv", content = function (file) {write.csv(conversion_design(),file, row.names = FALSE)})
output$downattraction <- downloadHandler(
filename = "AttractionDesign.csv", content = function (file) {write.csv(attraction_design(),file, row.names = FALSE)})
})
}
library(shiny)
ui <- fluidPage(
actionButton('refreshData','Refresh!'),
tableOutput('summaryTable')
)
server <- function(input, output, session){
df = eventReactive (input$refreshData, ignoreNULL = F, {
mtcars[sample(seq(nrow(mtcars)),5),]
})
output$summaryTable = renderTable({
head(df())
})
}
shinyApp(ui,server)
library(readxl) # Read excel
library(cmdstanr) # Interface to Stan
library(posterior) # Process Stan draws
library(doParallel); library(parallel) # R Multi-threading for EB
library(shiny)
source("https://raw.githubusercontent.com/klattery/Estimation-Ecosystem/master/EE_Functions_Stan4.0.R")
source("https://raw.githubusercontent.com/klattery/Estimation-Ecosystem/master/Stan_RShiny_UI.R")
filename <- list() # Placeholder for filenames to import (data, covariates, excel specs)
#set_cmdstan_path("/home/rstudio/cmdstan")
dir <- list(data = "/home/rstudio/CBC/data", # data files
work = "C:/Users/K.Lattery/OneDrive - SKIM/Temp", # output and other work
stanmodel = "/home/rstudio/CBC/StanCode", # code for Stan Model
stanout = "C:/Users/K.Lattery/OneDrive - SKIM/Temp" # Stan output
)
gen_sim_pop
