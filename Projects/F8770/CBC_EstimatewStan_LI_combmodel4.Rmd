---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
chunk_output_type: console
---
*CODE FOR ESTIMATING CONJOINT HB USING STAN*
  Run each step (1-5) by clicking on green arrow at far right: Run Current Chunk
  Step 2 prompts with form to input your data and coding specs
  Step 3 creates a subfolder (prefix_date-GMT) of Home/CBC for output 

###################################### 
## 1. RUN: LOAD PACKAGES
```{r Setup}
library(readxl) # Read excel
library(cmdstanr) # Interface to Stan
library(posterior) # Process Stan draws
library(doParallel); library(parallel) # R Multi-threading for EB
library(shiny)
library(sqldf)
source("https://raw.githubusercontent.com/klattery/Estimation-Ecosystem/master/EE_Functions_Stan4.3.R")
source("https://raw.githubusercontent.com/klattery/Stan/master/RShiny/Stan_CBC_RShinyUI.R")
#set_cmdstan_path("/home/rstudio/cmdstan")
dir <- list(work = "/home/rstudio/CBC", # output and other work
            stanmodel = "/home/rstudio/CBC/StanCode", # code for Stan Model
            stanout = "/home/rstudio/CBC/StanCode" # Stan output 
            )
dir <- list(work = "C:/Users/K.Lattery/SKIM/LinkedIn - 4. Analysis/3. HB_Stan/Kevin/Comb_Model", 
            stanmodel = "C:/Users/K.Lattery/SKIM/LinkedIn - 4. Analysis/3. HB_Stan/Kevin/Comb_Model", 
            stanout = "C:/StanRuns" 
            )

system(paste0("echo ", askpass::askpass(prompt = "Enter RStudio password in SKIMVERSE to allow auto-STOP of instance after running:") , 
              " | sudo -S chmod a+s /sbin/shutdown"))
```


############################################### 
## *2. FORM POPS-UP TO SPECIFY FILES*
#### `MANDATORY INPUT FORM`
#### VERIFY data_conjoint, specs\_, data_cov
```{r Load Data}
shinyApp(env_shiny$ui_1, env_shiny$server_1)
cat("Check Step 2 imported your data accurately:
  data_conjoint = stacked data file
  specs_*       = Excel specs")
```

################################################ 
## 3. RUN: CODE AND PREPARE DATA FOR STAN
#### CREATE SUBFOLDER FOR CBC OUTPUT
#### CHECK: CONSOLE OUTPUT LOOKS RIGHT
```{r Code and Prepare}
col_id_task_dep <- c(1,2,ncol(data_conjoint)) # Columns for id, task, dep
# 3) Code and Prepare data_stan =============
indcode_spec <- indcode_spec_files(data_conjoint, specs_att_coding,
                                   specs_pair_constraints, 
                                   control_code$add_none, col_id_task_dep[3]) # Code and constraints each attribute
# Custom
indcode_spec$`InMail Messaging` <- ordcode(data_conjoint, "InMail Messaging",cut_pts = 1:6, thermcode = TRUE, con_sign = 1)
###########

# Here is where you would do any custom coding indcode_spec[[i]] <- "syntax"
if (!is.null(indcode_spec)){
  indcode_list <- make_codefiles(indcode_spec) # Combine specifications above into one list
  data_stan <- prep_file_stan(idtaskdep = data_conjoint[,col_id_task_dep],
                              indcode_list = indcode_list,
                              data_cov = data_cov, specs_cov_coding = specs_cov_coding,
                              check_collinearity = control_code$check_collinearity,
                other_data = data_conjoint[,colnames(data_conjoint) %in% c("Product","Job_Posts_r","Response")])
  if (control_code$add_none){
    if  (is.null(indcode_spec$None$message)){
      cat("\nDid not Add a 'None' as no rows of all 0 found.\n")
    } else cat(indcode_spec$None$message)  
  }
  time_start <- format(Sys.time(), '%y%m%d-%H%M%S')
  out_folder <- paste0(control_code$out_prefix, "_", time_start)
  stan_outname <- paste0(out_folder, "_StanOut")  
  control_code$dir_run <- create_tempdir(dir, out_folder, control_code$out_prefix, stan_outname, save_specs = TRUE, code_master = data_stan$code_master)
  message("\n","\n","Created Directory for Output:", control_code$dir_run, "\n")
} else cat("!! STOP NOW and FIX NAMES that do not match !!")
```

################################################ 
## 3a. Add matrix for combining Product 6 posts and None
```{r Custom}
kdata <- cbind(data_stan$idtask, data_stan$ind)
get_comb_matrix <- function(t){
  x <- kdata[data_stan$start[t]:data_stan$end[t],]
  result <- matrix(0, nrow(x), 7)
  none_row <- match(1, x$None1_5)
  for (i in 1:nrow(x)){
    if (x$Int_Posts[i] == 0) result[i,i] <- 1
    if (x$Int_Posts[i] == 1){
      result[none_row,i] <- 1
      result[i,i] <- .001 # This will 0 out anyway as it is never chosen
    } 
  }
  return(result)
}
data_stan$comb_probs <- do.call(rbind, lapply(1:data_stan$T, get_comb_matrix))
check <- cbind(data_stan$comb_probs, int = kdata$Int_Posts, none =kdata$None1_5, dep = data_stan$dep)

process_utilities <- function(data_stan, utilities, out_prefix, dir_run,
                                       task_type = NULL, inv_logit_thresh = NULL){
  # Compute predictions
  row_weights <- data_stan$wts[data_stan$idtask_r] # convert task weights to row weights
  if (is.null(task_type)){ # Standard MNL
    pred_all <- do.call(rbind, lapply(1:data_stan$T,
                                      function(t){
                                        U <- exp(data_stan$ind[data_stan$start[t]:data_stan$end[t],] %*%
                                                   utilities[data_stan$task_individual[t],])
                                        pred <- U/sum(U)
                                        return(data.frame(pred = pred, U = U))
                                      }
    )) # lapply, rbind
  } else {
    pred_all <- do.call(rbind, lapply(1:data_stan$T,
                                      function(t){
                                        if (task_type[t] == 1){ # MNL
                                          U <- exp(data_stan$ind[data_stan$start[t]:data_stan$end[t],] %*%
                                                     utilities[data_stan$task_individual[t],])
                                          pred <- U/sum(U)
                                        }
                                        if (task_type[t] == 2){ # Inv Logit
                                          U <- exp(data_stan$ind[data_stan$start[t]:data_stan$end[t],] %*%
                                                     utilities[data_stan$task_individual[t],])
                                          if (is.null(inv_logit_thresh)){
                                            pred <- U/(1+U)
                                          } else pred <- U/(exp(inv_logit_thresh[t]) + U)
                                        }
                                        return(pred)
                                      }
    )) # lapply, rbind                                   
  }
  utilities_r <- utilities %*% t(data_stan$code_master)
  util_name <- paste0(out_prefix,"_utilities_r.csv")
  pred_name <- paste0(out_prefix,"_preds_meanpt.csv")
  failcon_name <- paste0(out_prefix,"_utilities_failcon.csv")
  obs_vs_pred_name <- paste0(out_prefix,"_obs_vs_pred.csv")
  
  LL_id <- rowsum(log(pred_all) * data_stan$dep * row_weights, data_stan$match_id)
  sum_wts <- rowsum(data_stan$dep * row_weights, data_stan$match_id)
  sum_wts[sum_wts == 0] <- 1
  header <- data.frame(id = data_stan$resp_id, rlh = exp(LL_id/sum_wts))
  message(paste0(
    "Saving: \n",
    " Respondent mean utilities: ", util_name, "\n",
    " Predictions for data     : ", pred_name, "\n",
    " Observed vs Predicted    : ", obs_vs_pred_name 
  ))
  
  write.table(cbind(header, utilities_r), file = file.path(dir_run, util_name), sep = ",", na = ".", row.names = FALSE)
  
  pred_all_export <- cbind(data_stan$idtask, wts = row_weights, dep = data_stan$dep, pred = pred_all)
  write.table(pred_all_export, file = file.path(dir_run, pred_name), sep = ",", na = ".", row.names = FALSE)
  if (ncol(data_stan$ind_levels) >0){
    obs_vs_pred <- obs_vs_pred(pred_all_export[,3:5], data_stan$ind_levels)
    write.table(obs_vs_pred, file = file.path(dir_run, obs_vs_pred_name), sep = ",", na = ".", row.names = FALSE)
  } else message("No Categorical Variables found for observed vs predicted")
  # Check if utilities meet constraints
  con_matrix <- diag(data_stan$con_sign)
  con_matrix <- rbind(con_matrix[rowSums(con_matrix !=0) > 0,,drop = FALSE], data_stan$paircon_matrix)
  bad_ids <- rowSums(((utilities %*% t(con_matrix)) < 0)) > 0
  if (sum(bad_ids) > 0){
    message(paste0(sum(bad_ids), " Respondents had reversals from constraints.\n",
                   "Reversals saved to: ", failcon_name))
    write.table(cbind(header, utilities_r)[bad_ids,], file = file.path(dir_run, failcon_name), sep = ",", na = ".", row.names = FALSE)
  } else message(" All respondent mean utilities obey constraints")
}

```

################################################ 
## 3b. Add Posts Data
```{r}
posts_max <- read.csv(file.path(dir$work,"num_posts_max.csv"))
ind_finite <- NULL
ind_infinite <- NULL
ind_posts <- NULL
dep_posts <- NULL
for (t in 1:data_stan$T){
  data_task <- data_stan$other_data[data_stan$start[t]:data_stan$end[t],]
  ind_finite <- c(ind_finite, as.numeric(data_task$Job_Posts_r == 1))
  ind_infinite <- c(ind_infinite, as.numeric(data_task$Job_Posts_r > 1))
  ind_posts <- c(ind_posts, as.numeric(data_task$Product == 6))
  dep1 <- data_task$Response[data_task$Product == 6]
  if (length(dep1) == 0) dep1 <- 0 # Task does not have none
  kmax <- posts_max$Max_Posts[data_stan$task_individual[t]]
  if (kmax > 0) dep1 <- dep1/kmax
  dep_posts <- c(dep_posts, dep1)  
}
data_stan$ind_posts <- ind_posts
data_stan$ind_finite <- ind_finite
data_stan$ind_infinite <- ind_infinite
data_stan$dep_posts <- dep_posts

```

################################################### 
## 5. OPTIONALLY CHANGE DEFAULTS
#### THEN RUN TO ESTIMATE MODEL
```{r HB Estimate}
##################################
# MODELING OPTIONS Defaults usually fine ====
data_model <- list(
  iter_warmup = 400, # warmup of 400 is plenty
  iter_sampling = 400, # sampling of 400 is plenty
  df = 2, # Must be >1 (recommend 2)
  prior_cov_scale = 1, # default 1# recommend df = 2 for Wishart
  con_use = 1, # 0 = ignore constraints, 1 = use
  con_factors = c(mult = .25, bound = 2), # Default (.25, 2 was 1.5) must be >0
  threads_per_chain = data_stan$threads_rec,
  agg_model = NULL, tag = NULL, ind = NULL, resp_id = NULL
)
control_code <- modifyList(control_code, list(
  export_draws_betas = FALSE, # Export respondent beta draws 
  export_draws_means = TRUE, # Mean of respondent betas
  export_draws_alphas = FALSE) # Raw alpha parameter (unconstrained)
)
data_model$splitsize <- round(.5 + data_stan$I/(4 * data_model$threads_per_chain))
##################################
# ESTIMATE MODEL =============
rm(indcode_spec); rm(indcode_list); gc() # Clear RAM
stan_file <- "BaseHB_IWnorm_LIcomb4.stan" # stan model in dir$stanmodel"
HB_model <- cmdstan_model(file.path(dir$stanmodel,stan_file), quiet = TRUE,
                          cpp_options = list(stan_threads = TRUE, STAN_CPP_OPTIMS = TRUE))
HB_fit <- HB_model$sample(modifyList(data_stan, data_model),
                iter_warmup = data_model$iter_warmup,
                iter_sampling = data_model$iter_sampling,
                output_dir = dir$stanout,
                output_basename = stan_outname, 
                chains = 2, parallel_chains = 2,
                threads_per_chain = data_model$threads_per_chain,
                save_warmup = TRUE, refresh = 10,
                adapt_delta = .8, seed = 123, init = .1,
                show_messages = FALSE, diagnostics = NULL)
# Save key aspects of HB_fit
meta_data <- HB_fit$metadata()
meta_data$output_files <- HB_fit$output_files()
meta_data$return_codes <- HB_fit$return_codes()
meta_data$inv_metric <- lapply(HB_fit$inv_metric(), diag)
saveRDS(meta_data, file.path(control_code$dir_run, paste0(control_code$out_prefix, "_meta_data.rds")))

#####  Check Convergence, Export Files  
if (min(meta_data$return_codes) == 0){
  cat("Reading draws from Stan csv output into R (large files take time)...")
  draws_beta <- read_cmdstan_csv(meta_data$output_files, variables = "beta_ind", format = "draws_list")
  draws_beta$warmup_draws <- NULL # to save space
  utilities <- get_mean_beta(draws_beta) # computes mean point estimates from draws
  checkconverge_export(draws_beta, vnames = colnames(data_stan$code_master), control_code$out_prefix, control_code$dir_run, control_code$export_draws_betas, control_code$export_draws_means )
  process_utilities(data_stan, utilities, control_code$out_prefix, control_code$dir_run)
  if (control_code$export_draws_alphas) check_draws_vector(meta_data$output_files, "alpha", colnames(data_stan$ind), control_code$dir_run, control_code$out_prefix)
  if (data_stan$P_cov > 0) covariate_means <- get_covariates(meta_data$output_files, data_stan, control_code$dir_run, control_code$out_prefix)
  if (control_code$est_EB & exists("draws_beta") & exists("data_stan")){
    linux <- (Sys.info()[1] != "Windows")
    if (linux) r_cores <- min(8,max(detectCores() -1,1)) # Number of cores to use for EB
    if (!linux) r_cores <- min(4,max(detectCores() -1,1)) # Number of cores to use for EB
    eb_betas_est(data_stan, draws_beta, data_stan$x0, r_cores,
               control_code$out_prefix, control_code$dir_run, cov_scale = 1, linux)
  }
} else message("Stan Estimation Did not Finish")
if (control_code$auto_stop){
  save.image(".RData")
  system('shutdown', wait = FALSE)
} 
##################################
```

```{r}
write.csv(data_stan$other_data, file.path(control_code$dir_run, "other.data.csv"))
check_draws_vector2 <- function(output_files, stan_vector, vector_labels = NULL, out_dir, out_prefix){
  # stan_vector is vector/1D array or scalar
  # vector labels are names for each item in vector, NULL auto assigns
  draws_stan_var <- read_cmdstan_csv(output_files, variables = stan_vector, format = "draws_list")
  draws_stan_df <- lapply(draws_stan_var$post_warmup_draws, function(x) do.call(cbind, x))
  fit_stats_var <- plot_draws_df(draws_stan_df, vector_labels, toupper(stan_vector),
                                 pdf_path = file.path(out_dir,paste0(out_prefix,"_trace_",stan_vector,".pdf")))
  write.table(fit_stats_var, file = file.path(out_dir, paste0(out_prefix,"_fit_stats_", stan_vector,".csv")), sep = ",", na = ".", row.names = FALSE)
return(fit_stats_var)  
}

b_finite <- check_draws_vector2(meta_data$output_files, "b_finite", colnames(data_stan$resp_id), control_code$dir_run, control_code$out_prefix)

b_infinite_delta <- check_draws_vector2(meta_data$output_files, "b_infinite_delta", colnames(data_stan$resp_id), control_code$dir_run, control_code$out_prefix)

b_none_posts <- check_draws_vector2(meta_data$output_files, "none_posts", colnames(data_stan$resp_id), control_code$dir_run, control_code$out_prefix)

util_post_vars <- data.frame(id = data_stan$resp_id,
                        b_finite = b_finite$mean,
                        b_infinite = b_finite$mean + b_infinite_delta$mean,
                        b_none_posts = b_none_posts$mean)
write.csv(util_post_vars, file.path(control_code$dir_run, "util_post_vars.csv"))
# Custom prediction function for each task
pred_license <- rep(0, data_stan$N)
pred_posts <- rep(NA, data_stan$T)
for (t in 1:data_stan$T){
 t_start <- data_stan$start[t] # First row or task
 t_end <- data_stan$end[t]   # End row of task
 U_exp <- exp(data_stan$ind[t_start:t_end,] %*%
                utilities[data_stan$task_individual[t],])
 predMNL <- U_exp/sum(U_exp)
 predMNL_adj <- data_stan$comb_probs[t_start:t_end,(1:nrow(predMNL))] %*% predMNL
 pred_license[t_start:t_end] <- predMNL_adj

 # Now do optional posts
 utask_posts <- sum(data_stan$ind_posts[t_start:t_end] * U_exp)
 if (utask_posts > 0){
   utask_sum <- sum(U_exp)
   utask_fin <- log(utask_sum - sum(data_stan$ind_finite[t_start:t_end] * U_exp)) -
                log(utask_sum)
   utask_inf <-log(utask_sum - sum(data_stan$ind_infinite[t_start:t_end] * U_exp)) -
                 log(utask_sum)   
   id_row <- data_stan$task_individual[t]
   u_posts <- log(utask_posts) +
     utask_fin * util_post_vars$b_finite[id_row] +
     utask_inf * util_post_vars$b_infinite[id_row]
   pred_posts[t] <- exp(u_posts)/(exp(u_posts) + exp(util_post_vars$b_none_posts[id_row]))
 }
}

pred_license <- cbind(data_stan$idtask, pred_license, data_stan$dep)
pred_posts_all <- data.frame(id = data_stan$resp_id[data_stan$task_individual], pred = pred_posts, obs = data_stan$dep_posts)

write.csv(pred_license, file.path(control_code$dir_run, "pred_license.csv"), row.names = FALSE)
write.csv(pred_posts_all, file.path(control_code$dir_run, "pred_posts.csv"))
```


