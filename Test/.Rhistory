prior_cor <- cov2cor(prior_cov)
data_list$P <- ncol(prior_cor) # or sku_to_att
data_list$prior_cor <- prior_cor
cbind(colnames(prior_cov), c(colnames(data_list$sku_to_att),"logprice"),names_full)
library(readxl)
library(shiny)
source("https://raw.githubusercontent.com/klattery/Estimation-Ecosystem/master/EE_Functions_Stan2.2.R")
dir_base <- "C:/Users/K.Lattery/SKIM/Philip Morris - 3. Prework/3 final data"
masterfile <- "F4251 Data Masterfile_3.2.xlsm"
masterfile_PMI <- "PMI_masterfile.xlsx"
# Clean att_decompose
att_decompose <- data.frame(read_xlsx(file.path(dir_base, masterfile_PMI), range = "SKUs!A1:M1000"))
att_decompose <- att_decompose[!is.na(att_decompose$variant),] # Remove NA variants
table(att_decompose$Color_Flavour)
att_decompose$Color_Flavour[is.na(att_decompose$Color_Flavour)] <- "NONE"
att_decompose$Price_tier[att_decompose$Price_tier == "5 LOW NON-FILTER"] <- "4 LOW FILTER"
att_decompose$Thickness[att_decompose$Thickness == "XSL"] <- "SSL"
att_decompose$Length[att_decompose$Length == "LTK"] <- "100"
skus_conjoint <- data.frame(read_xlsx(file.path(dir_base, masterfile), range = "one2many!AS1:AV837"))
skus_conjoint <- skus_conjoint[skus_conjoint$Keep==1,]
# Get flavor mix
flavor_mix_code <- data.frame(read_xlsx(file.path(dir_base, masterfile), range = "Decomposing_KL!AH18:AR33"))
# Convert flavor to mix
flavor_in <- att_decompose$Color_Flavour
kmatch <- match(flavor_in, flavor_mix_code$Flavor)
flavor_code <- flavor_mix_code[kmatch,]
flavor_code <- flavor_mix_code[kmatch,-1]
flavor_code[is.na(flavor_code)] <- 0
flavor_code1 <- flavor_code[,c(1,3,4,5,6,9)] # Fruits
flavor_code2 <- flavor_code[,-1 * c(1,3,4,5,6,9)]
flavor_code2 <- data.frame(apply(flavor_code2, 1, function(x) match(1,x)))
colnames(flavor_code2) <- "Color"
fruit_cps <- rep(1, nrow(att_decompose)) # No CPS, No Fruit
fruit_cps[att_decompose$CPS] <- 3
fruit_cps[!att_decompose$CPS & rowSums(flavor_code1) > 0] <- 2
table(fruit_cps, att_decompose$CPS)
look <- cbind(fruit_cps, att_decompose$CPS, rowSums(flavor_code1), rowSums(flavor_code2))
# Format and Tier subsets
format <- as.factor(att_decompose$Thickness)
Price_tier <- data.frame("Price_tier" = as.numeric(substr(att_decompose$Price_tier, 1, 1)))
Tier1_format <- rep(0, nrow(att_decompose))
Tier2_format <- Tier1_format
Tier3_format <- Tier1_format
Tier4_format <- Tier1_format
Tier1_format[Price_tier == 1] <- format[Price_tier == 1]
Tier2_format[Price_tier == 2] <- format[Price_tier == 2]
Tier3_format[Price_tier == 3] <- format[Price_tier == 3]
Tier4_format[Price_tier == 4] <- format[Price_tier == 4]
Tiers_format <- data.frame(cbind(Tier1_format, Tier2_format, Tier3_format, Tier4_format))
# Put together
sku_att_levels <- data.frame(cbind(att_decompose[,c(1,3)], Brand = att_decompose$Brand, Length = att_decompose$Length,Price_tier, Tiers_format, fruit_cps, flavor_code1, flavor_code2))
View(sku_att_levels)
saveRDS(sku_att_levels, file = file.path(dir_base,"02 Modelling/EvokedwAtts","sku_att_levels3.rds"))
# Code attributes all indicator
indcode_spec <- list()
indcode_spec[[1]] <- catcode(sku_att_levels, "Brand", codetype = 1, setna = NA)
indcode_spec[[2]] <- catcode(sku_att_levels, "Length", codetype = 1, setna = NA)
indcode_spec[[3]] <- catcode(sku_att_levels, "Price_tier", codetype = 1, setna = NA)
indcode_spec[[4]] <- catcode(sku_att_levels, "Tier1_format", codetype = 1, setna = 0)
indcode_spec[[5]] <- catcode(sku_att_levels, "Tier2_format", codetype = 1, setna = 0)
indcode_spec[[6]] <- catcode(sku_att_levels, "Tier3_format", codetype = 1, setna = 0)
indcode_spec[[7]] <- catcode(sku_att_levels, "Tier4_format", codetype = 1, setna = 0)
indcode_spec[[8]] <- catcode(sku_att_levels, "fruit_cps", codetype = 1, setna =0)
indcode_spec[[9]] <- usercode(sku_att_levels, 11:16) # Flavors coded as mixtures
indcode_spec[[9]]$con_sign <- rep(0, 16-11+1)
indcode_spec[[10]] <- catcode(sku_att_levels, "Color", codetype = 1, setna = 0)
indcode_list <- make_codefiles(indcode_spec)
rownames(indcode_list$code_master)
colnames(indcode_list$code_master)
sku_att_ind <- data.frame(cbind(att_decompose[,c(1,3)], indcode_list$indcode))
saveRDS(sku_att_ind, file = file.path(dir_base,"02 Modelling/EvokedwAtts","sku_att_ind3.rds"))
# Code attributes
indcode_spec <- list()
indcode_spec[[1]] <- catcode(sku_att_levels, "Brand", codetype = 1, setna = NA)
indcode_spec[[2]] <- catcode(sku_att_levels, "Length", codetype = 3, reflev = 2, setna = NA)
indcode_spec[[3]] <- catcode(sku_att_levels, "Price_tier", codetype = 3, setna = NA)
indcode_spec[[4]] <- catcode(sku_att_levels, "Tier1_format", codetype = 3, reflev = 1, setna = 0)
indcode_spec[[5]] <- catcode(sku_att_levels, "Tier2_format", codetype = 3, reflev = 1, setna = 0)
indcode_spec[[6]] <- catcode(sku_att_levels, "Tier3_format", codetype = 3, reflev = 1, setna = 0)
indcode_spec[[7]] <- catcode(sku_att_levels, "Tier4_format", codetype = 3, reflev = 1, setna = 0)
indcode_spec[[8]] <- catcode(sku_att_levels, "fruit_cps", codetype = 3, reflev = 1, setna =0)
indcode_spec[[9]] <- usercode(sku_att_levels, 11:16) # Flavors coded as mixtures
indcode_spec[[9]]$con_sign <- rep(0, 16-11+1)
indcode_spec[[10]] <- catcode(sku_att_levels, "Color", codetype = 3, reflev = 1, setna = 0)
indcode_list <- make_codefiles(indcode_spec)
rownames(indcode_list$code_master)
colnames(indcode_list$code_master)
sku_att_all <- data.frame(cbind(att_decompose[,c(1,3)], indcode_list$indcode))
saveRDS(sku_att_all, file = file.path(dir_base,"02 Modelling/EvokedwAtts","sku_att_all3.rds"))
look <- indcode_spec[[10]]
saveRDS(indcode_list, file = file.path(dir_base,"02 Modelling/EvokedwAtts","indcode_list3.rds"))
saveRDS(indcode_list, file = file.path(dir_base,"02 Modelling/EvokedwAtts","indcode_list3.rds"))
write.csv(indcode_list$code_master, file = file.path(dir_base,"02 Modelling/EvokedwAtts","code_master3.csv"))
View(prior_cov)
#################################################
# Must add Milano
as.matrix(colnames(prior_cov))
conjoint_cov <- readRDS(file.path(dir_master,"02 Modelling/EvokedwAtts/Coding5","conjoint_cov_atts_wprice.rds"))
kmatch <- match("Length_LTK", colnames(conjoint_cov))
conjoint_cov <- conjoint_cov[-kmatch, -kmatch] # Remove LTK
#################################################
# Must add Milano
as.matrix(colnames(conjoint_cov))
colnames(prior_cov)
setdiff(names_full, colnames(prior_cov))
vars_add <- setdiff(names_full, colnames(prior_cov))
vars_add
prior_cov_match <- diag(ncol(prior_cov) + length(vars_add))
colnames(prior_cov_match) <- c(colnames(prior_cov), vars_add)
colnames(prior_cov_match)
prior_cov_match[1:ncol(prior_cov), 1:ncol(prior_cov)] <- prior_cov
match(colnames(prior_cov_match), names_full)
kmatch <- match(colnames(prior_cov_match), names_full)
if (sum(is.na(kmatch)) >0) message("Fatal Error: did not match prior cov to data")
if (sum(is.na(kmatch)) >0){
message("Fatal Error: did not match prior cov to data")
} else prior_cov_match <- prior_cov_match[kmatch, kmatch]
prior_cor <- cov2cor(prior_cov)
data_list$P <- ncol(prior_cor) # or sku_to_att
data_list$prior_cor <- prior_cor
cbind(colnames(prior_cov), c(colnames(data_list$sku_to_att),"logprice"),names_full)
prior_cor <- cov2cor(prior_cov_match)
data_list$P <- ncol(prior_cor) # or sku_to_att
data_list$prior_cor <- prior_cor
cbind(colnames(prior_cov), c(colnames(data_list$sku_to_att),"logprice"),names_full)
cbind(colnames(prior_cor), c(colnames(data_list$sku_to_att),"logprice"),names_full)
###################################################
# 5. Define Attribute Levels and Prior Conjoint
# This based on skus in Conjoint *OR* Specific Real World Data set
###############################################
conjoint_cov <- readRDS(file.path(dir_master,"02 Modelling/EvokedwAtts/Coding5","conjoint_cov_atts_wprice.rds"))
kmatch <- match("Length_LTK", colnames(conjoint_cov))
conjoint_cov <- conjoint_cov[-kmatch, -kmatch] # Remove LTK
names_full <- c(colnames(data_list$sku_to_att),"logprice")
names_conjoint <- colnames(conjoint_cov)
idx <- match(names_conjoint, names_full); sum(is.na(idx))
message("These conjoint attributes will not be evaluated in our data file")
names_conjoint[is.na(idx)]
prior_cov <- conjoint_cov[!is.na(idx), ! is.na(idx)]
vars_add <- setdiff(names_full, colnames(prior_cov)) # No prior for these
vars_add
prior_cov_match <- diag(ncol(prior_cov) + length(vars_add))
colnames(prior_cov_match) <- c(colnames(prior_cov), vars_add)
colnames(prior_cov_match)
c(colnames(prior_cov), vars_add)
###################################################
# 5. Define Attribute Levels and Prior Conjoint
# This based on skus in Conjoint *OR* Specific Real World Data set
###############################################
conjoint_cov <- readRDS(file.path(dir_master,"02 Modelling/EvokedwAtts/Coding5","conjoint_cov_atts_wprice.rds"))
colnames(prior_cov)
###################################################
# 5. Define Attribute Levels and Prior Conjoint
# This based on skus in Conjoint *OR* Specific Real World Data set
###############################################
conjoint_cov <- readRDS(file.path(dir_master,"02 Modelling/EvokedwAtts/Coding5","conjoint_cov_atts_wprice.rds"))
kmatch <- match("Length_LTK", colnames(conjoint_cov))
conjoint_cov <- conjoint_cov[-kmatch, -kmatch] # Remove LTK
names_full <- c(colnames(data_list$sku_to_att),"logprice")
names_conjoint <- colnames(conjoint_cov)
idx <- match(names_conjoint, names_full); sum(is.na(idx))
message("These conjoint attributes will not be evaluated in our data file")
names_conjoint[is.na(idx)]
prior_cov <- conjoint_cov[!is.na(idx), ! is.na(idx)]
vars_add <- setdiff(names_full, colnames(prior_cov)) # No prior for these
vars_add
prior_cov_match <- diag(ncol(prior_cov) + length(vars_add))
colnames(prior_cov_match) <- c(colnames(prior_cov), vars_add)
prior_cov_match[1:ncol(prior_cov), 1:ncol(prior_cov)] <- prior_cov
View(prior_cov_match)
kmatch <- match(colnames(prior_cov_match), names_full)
if (sum(is.na(kmatch)) >0){
message("Fatal Error: did not match prior cov to data")
} else prior_cov_match <- prior_cov_match[kmatch, kmatch]
View(prior_cov_match)
kmatch
colnames(prior_cov_match)
kmatch <- match(colnames(prior_cov_match), names_full)
kmatch
prior_cov_match <- diag(ncol(prior_cov) + length(vars_add))
colnames(prior_cov_match) <- c(colnames(prior_cov), vars_add)
colnames(prior_cov_match)
prior_cov_match[1:ncol(prior_cov), 1:ncol(prior_cov)] <- prior_cov
View(prior_cov_match)
kmatch <- match(colnames(prior_cov_match), names_full)
kmatch
check <- prior_cov_match
colnames(check)
check <- check[kmatch, kmatch]
colnames(check)
check <- prior_cov_match
colnames(check)
check2 <- check[kmatch, kmatch]
colnames(check2)
kmatch
check <- prior_cov_match
colnames(check)
cbind(colnames(check),kmatch)
check2 <- check[c(1,3,2), c(1,3,2)]
colnames(check2)
check2 <- check[kmatch, kmatch]
colnames(check2)
View(check2)
check2 <- check[c(1,3,2), c(1,3,2)]
colnames(check2)
check2 <- check[vec, vec]
vec <- c(1,3,2)
check2 <- check[vec, vec]
colnames(check2)
View(check2)
View(prior_cov)
kmatch
vec <- c(1:20,22:65,21)
cbind(vec, kmatch)
check2 <- check[vec, vec]
colnames(check2)
kmatch <- match(names_full, colnames(prior_cov_match))
if (sum(is.na(kmatch)) >0){
message("Fatal Error: did not match prior cov to data")
} else prior_cov_match <- prior_cov_match[kmatch, kmatch]
colnames(check2)
kmatch
prior_cov_match <- diag(ncol(prior_cov) + length(vars_add))
colnames(prior_cov_match) <- c(colnames(prior_cov), vars_add)
prior_cov_match[1:ncol(prior_cov), 1:ncol(prior_cov)] <- prior_cov
kmatch <- match(names_full, colnames(prior_cov_match))
kmatch
check <- prior_cov_match
cbind(colnames(check),kmatch)
colnames(prior_cov_match)
kmatch <- match(names_full, colnames(prior_cov_match))
kmatch
check <- prior_cov_match
cbind(colnames(check),kmatch)
kmatch
check <- prior_cov_match
check2 <- check[kmatch, kmatch]
colnames(check2)
kmatch <- match(names_full, colnames(prior_cov_match))
kmatch
if (sum(is.na(kmatch)) >0){
message("Fatal Error: did not match prior cov to data")
} else prior_cov_match <- prior_cov_match[kmatch, kmatch]
colnames(prior_cov_match)
prior_cor <- cov2cor(prior_cov_match)
data_list$P <- ncol(prior_cor) # or sku_to_att
data_list$prior_cor <- prior_cor
cbind(colnames(prior_cor), c(colnames(data_list$sku_to_att),"logprice"),names_full)
test2 <- chol(prior_cor) # Test that our prior has cholesky
# Just for reference
indcode_list <- readRDS(file.path(dir_master,"02 Modelling/EvokedwAtts","indcode_list3.rds"))
code_master_data <- indcode_list$code_master
# Add logprice
code_master_data <- cbind(code_master_data, logprice = 0)
code_master_data <- rbind(code_master_data, logprice = 0)
code_master_data[nrow(code_master_data), ncol(code_master_data)] <- 1
col_in <- colnames(code_master_data)
col_new <- sub(" ", ".", col_in)
col_new <- sub("&", ".", col_new)
col_new <- sub("/", ".", col_new)
colnames(code_master_data) <- col_new
idx <- match(col_new, names_full); sum(is.na(idx))
col_new[is.na(idx)]
code_master_data <- code_master_data[,!is.na(idx)]
colnames(code_master_data)
cbind(colnames(prior_cov), c(colnames(data_list$sku_to_att),"logprice"),names_full, colnames(code_master_data))
cbind(colnames(prior_cor), c(colnames(data_list$sku_to_att),"logprice"),names_full, colnames(code_master_data))
# CHECK DATA ALIGNMENT
data_list$code_master_data <- code_master_data
###################################################
# 4. Add Price Tier (used for some models)
# Can skip section if tiers not needed
##################################################
# Add tier info
sku_info <- data_list$sku_to_att
recode_base <- matrix(c(-1,-1,1,0,0,1), nrow = 3, ncol = 2, byrow = TRUE)
recodes <- matrix(0, nrow = 4*3, ncol = 4*2)
recodes[1:3,1:2] <- recode_base
recodes[4:6,3:4] <- recode_base
recodes[7:9,5:6] <- recode_base
recodes[10:12,7:8] <- recode_base # recodes has possible codes for us to categorize tier
as.matrix(colnames(sku_info))
###########  MANUAL  ####################
sku_info <- sku_info[,46:53] # MANUAL: Just the Tier_format stuff
sku_tier_v <- apply(sku_info, 1, function(x){
find_match <- apply(recodes, 1, function(compare){
sum(abs(x-compare)) # 0 will be a match
})
result <- match(0, find_match)
return(result)
})
table(sku_tier_v)
sku_tier_v[sku_tier_v %in% c(2,3)] <- 1 # Recode 2 and 3 into 1
sku_tier_v[sku_tier_v %in% c(5,6)] <- 4
sku_tier_v[sku_tier_v %in% c(9)] <- 7
table(sku_tier_v)
collapse <- c(1,0,0,2,0,0,3,4,0,5,6,7)
sku_tier_v <- collapse[sku_tier_v]
table(sku_tier_v)
sku_tier <- cbind(1:length(sku_tier_v), sku_tier_v) # Add sku number
i <- 1; j <- 12 # Test
max_tier <- max(sku_tier[,2])
price_mu_tier <- array(data = 0, dim = c(length(regions), length(periods), max_tier))
price_log_tier <- array(data = 0, dim = c(length(regions), length(periods), length(sku_tier_v), max_tier))
price_rel_tier <- array(data = 0, dim = c(length(regions), length(periods), length(sku_tier_v), max_tier))
price_rel_onevar <- array(data = 0, dim = c(length(regions), length(periods), length(sku_tier_v)))
# For each region, period, get mean(price) for tier
for (i in regions){ # fill in data_list
for (j in periods){
tier_code <- matrix(0, data_list$P_sku, max_tier)
price_code <- tier_code
exist_code <- tier_code
prices <- data_list$price[i,j,]
shares <- data_list$dist[i,j,] # was shares, using dist as proxy
tier_code[sku_tier] <- shares
price_code[sku_tier] <- prices
shares_tier <- colSums(tier_code)
mu_price_wtd <- (t(tier_code) %*% prices) /shares_tier
mu_price_wtd[is.na(mu_price_wtd)] <- 0
rel_price <- (sweep(price_code,2,mu_price_wtd, "/") - 0)
rel_price[is.na(rel_price)] <- 0
log_price_code <- price_code
log_price_code[price_code > 0] <- log(price_code[price_code >0])
price_mu_tier[i,j,] <- mu_price_wtd
price_rel_tier[i,j,,] <- rel_price
price_log_tier[i,j,,] <- log_price_code
price_rel_onevar[i,j,] <- rowSums(rel_price)
}
}
sum(is.na(price_rel_tier)); sum(is.na(price_log_tier))
hist(as.vector(price_mu_tier/100))
hist(as.vector(price_log_tier))
hist(as.vector(price_mu_tier/100))
look <- as.vector(price_rel_tier)
look <- look[look > 0]
hist(look)
data_list$n_tiers <- dim(price_mu_tier)[3] # First two used by Stan tier model
data_list$sku_tier <- sku_tier[,2]
data_list$price_mu_tier <- price_mu_tier # Compute these and transform later
data_list$price_rel_tier <- price_rel_tier
data_list$price_rel_onevar <- price_rel_onevar
##### Coding price_mu_tier & price_rel_onevar   ##############
tier_price <- data_list$price_mu_tier
mu_1 <- tier_price[1,,] # Periods 5-9 are not used in estimation anyway
tier_price[is.na(tier_price)] <- 130
hist(as.vector(tier_price/130), breaks = 40)
hist(as.vector(log(tier_price/130)), breaks = 30)
tier_price_code <- log(tier_price/130)
sum(is.na(tier_price_code)); sum(is.infinite(tier_price_code))
price_rel <- data_list$price_rel_onevar
look <- as.vector(price_rel)
look <- look[look > 0]
hist(look^2, breaks = 40)
hist(4*log(look), breaks=40)
hist(log(1 + exp(look)), breaks = 40)
price_rel_code <- log(data_list$price_rel_onevar)
price_rel_code[is.na(price_rel_code) | is.infinite(price_rel_code)] <- 0
quantile(price_rel_code)
data_list$tier_price <- tier_price_code # These actually used by Stan
data_list$price_rel <- price_rel_code
##################################################
saveRDS(data_list, file = file.path(dir_work, "data_list_AR_Top2_wpromo_wtier_combo.rds"))
dir_data <- "C:/Users/K.Lattery/SKIM/Philip Morris - F6886 Advanced modelling update Nov 21/3. Modelling/01 GT IMS top2"
dir_out <- file.path(dir_data)
dir_model <- "C:/Users/K.Lattery/Documents/GitHub/Stan/Test" # Location of Stan Code
dir_draws <- "C:/StanRuns/PMI" # Where Stan stores draws.  Recommend a folder that does not sync
linux <- FALSE
if (linux) {
dir_data <- gsub("C:/", "/mnt/c/", dir_data)
dir_out <- gsub("C:/", "/mnt/c/", dir_out)
dir_model <- gsub("C:/", "/mnt/c/", dir_model)
dir_draws <- gsub("C:/", "/mnt/c/", dir_draws)
}
# Specify threads for your computer
threads = list(parallel_chains = 2,
threads_per_chain = 24)
# Load data into R
data_list <- readRDS(file.path(dir_data, "data_list_AR_Top2_wpromo_wtier_combo.rds")) # Load data file
# Define tasks for estimation
max_p <- 42
task_periods <- rbind(
cbind(3:(max_p -1), 4:max_p),
cbind(3:(max_p -2), 5:max_p),
cbind(3:(max_p -6), 9:max_p)
)
tasks_all <- do.call(rbind, lapply(2:6, function(i) cbind(i, task_periods))) #1 Pan Russia
data_list$region <- tasks_all[,1]
data_list$per_lag <- tasks_all[,2]
data_list$per_new <- tasks_all[,3]
data_list$T <- length(data_list$per_lag)
reg_x_period <- unique(tasks_all[,-2])
# Specify Constraints and Priors
P <- data_list$P
I <- 1000
dim(data_list$wts)
data_list$wts[1,dim(data_list$wts)[2],]
#for (i in 62:65){ # Create holdouts
#  data_list$wts[,i,] <- 0
#}
# Tuning weights for att model so later periods weighted much more
min_p <-1
wts_period <- exp(2/(max_p - min_p) *(min_p:max_p - max_p))
wts_period <- wts_period/mean(wts_period)
#wts_period <- wts_period * .1
plot(1:length(wts_period), wts_period)
for (i in min_p:max_p){
data_list$wts[,i,] <- wts_period[i]
# data_list$wts_att[,i,] <- wts_period[i] * .25
data_list$wts_att[,i,] <- wts_period[i] * 1
}
att_sigma <- rep(10, P-1)
as.matrix(colnames(data_list$sku_to_att))
####   MANUAL   ############
att_sigma[56:61] <- 1 # Flavors
att_sigma[62:64] <- 2 # Colors
############################
data.frame(att = colnames(data_list$sku_to_att),att_sigma)
unique(data_list$per_new)
sku_n  <- colSums(data_list$skus_bin[1,,]) +
colSums(data_list$skus_bin[2,,]) +
colSums(data_list$skus_bin[3,,]) +
colSums(data_list$skus_bin[4,,]) +
colSums(data_list$skus_bin[5,,]) +
colSums(data_list$skus_bin[6,,])
sku_n  <- colSums(data_list$skus_bin[1,,])
# colSums(data_list$skus_bin[2,,]) +
# colSums(data_list$skus_bin[3,,]) +
# colSums(data_list$skus_bin[4,,]) +
# colSums(data_list$skus_bin[5,,]) +
# colSums(data_list$skus_bin[6,,])
sku_mean <- sku_n/1
dist_sigma <- (sku_mean - 1)/10
dist_sigma[dist_sigma > 1] <- 1
dist_sigma[dist_sigma < .05] <- .05
data_model <- list(
per_base = max_p,
P_int = data_list$P - 1,
I = I,
sim_pop_z = matrix(rnorm(I * P), nrow = P, ncol = I),
price_sigma = 2,
p_mu_mu = -1,
p_mu_sigma = 2,
trend_sigma = .1,
dist_sigma = dist_sigma, # Was 1
cov_diag_sigma = 2, # initial = 2
att_sigma = att_sigma,
ar_scale = 1,
df = 2,
cov_block = matrix(1, P, P),
splitsize = round(.5 + data_list$T/(4 * threads[[2]])),
lam_inv = 5, # For morphing max lam = .2
code_master_data = NULL,
codes_array = NULL,
tier_price = NULL, # Becaise we are not using tier price
price_rel = NULL
)
str(modifyList(data_list, data_model))
check <- (data.frame(lapply(modifyList(data_list, data_model), function(x) c(min(x), max(x),sum(is.na(x)),sum(is.infinite(x))))))
convert_3d <- function(x, logtrans = FALSE){
dims <- dim(x)
lev_sub <- lapply(1:dims[2], function(x) NA) # Create list with elements
result <- lapply(1:dims[1], function(x) lev_sub)
for (i in 1:dims[[1]]){ # fill in data_list
for (j in 1:dims[[2]]){
vec_one <- x[i,j,]
if(logtrans){
vec_one <- log(vec_one)
vec_one[is.infinite(vec_one)] <- 0
}
result[[i]][[j]] <- vec_one
}}
return(result)
}
convert_3d_m <- function(x){
dims <- dim(x)
result <- lapply(1:dims[1], function(x) NA)
for (i in 1:dims[[1]]){ # fill in data_list
result[[i]] <- x[i,,]
}
return(result)
}
test_function <- function(junk){
data_list$codes_array <- convert_3d(data_list$codes_array)
data_list$price <- convert_3d(data_list$price, logtrans = TRUE)
data_list$dist <- convert_3d(data_list$dist, logtrans = TRUE)
data_list$aware <- convert_3d(data_list$aware)
data_list$promo <- convert_3d(data_list$promo)
data_list$share <- convert_3d(data_list$share)
data_list$wts <- convert_3d(data_list$wts)
data_list$wts_att <- convert_3d(data_list$wts_att)
data_list$skus_bin <- convert_3d(data_list$skus_bin)
data_list$morph_rowtocol <- convert_3d_m(data_list$morph_rowtocol) # Convert to array of matrices
}
library("cmdstanr")
stan_file <- "Stan_Code_BlockCheckMax_Int10_popCC4_RW_newpriors2_data.stan"
str(modifyList(data_list, data_model))
HB_model <- cmdstan_model(file.path(dir_model,stan_file), quiet = TRUE,
cpp_options = list(stan_threads = TRUE))
data_model$task_beg <- 1
data_model$task_end <- data_list$T
# New Stuff
data_model$lag_use <- 1 - (data_list$codes %in% c(99999999)) # 1 for skus to use lag
as.matrix(colnames(data_list$code_master_data))
####   MANUAL   ############
data_model$nbrand <- 41 # Last brand level
data_model$b_promo_prior_mu = c(exist = .2, npl = .2) # .2 Bristol
HB_MLE$output()
HB_model$print() # Optional to view
look <- modifyList(data_list, data_model)
HB_MLE <- HB_model$optimize(modifyList(data_list, data_model), init = .1, seed = 0916,
refresh = 1, iter = 1000, output_dir =  dir_draws, threads = threads[[2]])
View(check)
